package Array.Middle;

//Offer: 一个整数数组 prices
//        其中第 i 个元素代表了第 i 天的股票价格
//        非负整数 fee 代表了交易股票的手续费用
//        你可以无限次地完成交易，但是你每笔交易都需要付手续费
//        如果你已经购买了一个股票，在卖出它之前你就不能再继续购买股票了
//注意：这里的一笔交易指买入持有并卖出股票的整个过程，每笔交易你只需要为支付一次手续费

//Target: 返回获得利润的最大值
public class D21_714_maxProfit {
//    解法1：动态规划
//    第 1 步：状态定义
//        dp[i][j] 表示 [0, i] 区间内，到第 i 天（从 0 开始）状态为 j 时的最大收益
//        这里 j 取两个值：
//            0 表示不持股；
//            1 表示持股
//    第 2 步：状态转移方程
//        dp[i][0]：当天不持股，可以由昨天不持股和昨天持股转换而来
//            昨天不持股，今天仍然不持股，则说明今天什么都没做
//            昨天持股，今天不持股，则说明今天卖出了一股
//                    这题有手续费，我们都规定，手续费在买入股票的时候，一起扣掉
//                    也可以规定在卖出一股的时候，扣除手续费，前后统一即可
//            dp[i][0] = max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
//
//        dp[i][1]：当天持股，也可以由昨天不持股和昨天持股转换而来
//            昨天不持股，今天持股，则说明今天买了一股，并且扣除了手续费
//            昨天持股，今天仍然持股，则说明今天什么都没做
//            dp[i][1] = max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
//    第 3 步：思考初始化
//        在第 0 天，不持股的初始化值为 0，持股的初始化值为 -prices[0] - fee（表示购买了一股且扣除了手续费）
//    第 4 步：思考输出
//        每一天都由前面几天的状态转换而来，最优值在最后一天，并且是不持股的状态
    public int maxProfit1(int[] prices, int fee) {
        int len = prices.length;
        if (len < 2) {
            return 0;
        }

        // dp[i][j] 表示 [0, i] 区间内，到第 i 天（从 0 开始）状态为 j 时的最大收益'
        // j = 0 表示不持股，j = 1 表示持股
        // 并且规定在买入股票的时候，扣除手续费
        int[][] dp = new int[len][2];

        dp[0][0] = 0;
        dp[0][1] = -prices[0] - fee;

        for (int i = 1; i < len; i++) {
            dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i]);
            dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee);
        }
        return dp[len - 1][0];
    }
//    时间复杂度：O(N)，这里 N 是股价数组的长度
//    空间复杂度：O(N)，状态数组有 N 行，2 列2 为常数，在计算复杂度的时候视为 1

    //优化空间复杂度
//    当前行总是参考上一行的值，可以使用滚动数组优化
//    且当前行是参考另一张表格上一行的值，因此直接把第 1 维砍掉都可以，并且计算状态的时候，因为是“螺旋”计算的
//    则公式改为：
//        dp[0] = Math.max(dp[0], dp[1] + prices[i]);
//        dp[1] = Math.max(dp[1], dp[0] - prices[i] - fee);
//    在状态转移的时候，这两行的顺序可以互换，原因如下：
//    dp[1]之所以可以利用当天的dp[0]，可分为两种情况：
//    1.当dp[0]=dp[0]时,今天的dp[0]相当于昨天的dp[0]，可直接利用
//    2.当dp[0]=dp[1] + prices[i]时，将dp[0]=dp[1] + prices[i]代入式子dp[1] = Math.max(dp[1], dp[0] - prices[i] - fee)
//    可得dp[1] = Math.max(dp[1], dp[1] + prices[i] - prices[i] - fee)
//    即dp[1] = Math.max(dp[1], dp[1] - fee)
//    由此可得，在dp[0]=dp[1] + prices[i]时，今天的d[1]必将等于昨日的d[1]，与d[0]无关
    public int maxProfit2(int[] prices, int fee) {
        int len = prices.length;
        if (len < 2) {
            return 0;
        }

        // j = 0 表示不持股，j = 1 表示持股
        // 并且规定在买入股票的时候，扣除手续费
        int[] dp = new int[2];

        dp[0] = 0;
        dp[1] = -prices[0] - fee;

        for (int i = 1; i < len; i++) {
            dp[0] = Math.max(dp[0], dp[1] + prices[i]);
            dp[1] = Math.max(dp[1], dp[0] - prices[i] - fee);
        }
        return dp[0];
    }

//    解法2：贪心算法
//    解决这个问题的关键是要知道什么时候该卖出，利润就等于卖出时价格减去之前遍历到的最小值再减去手续费，利润很好计算
//    那么怎么判断是该持有还是该卖出呢？
//    首先从第二个数开始遍历，如果它比第一个数小，那我们就不买第一天的，买第二天的股票（这个时候更新最小值min）
//    再来继续遍历，如果第三天的价格比第二天的高呢？（这个时候更新最大值max）这个时候卖不卖？
//        无论卖或者不卖都让人为难，因为你不知道后面价格是不是会更高
//        所以我们是否卖出股票应该由接下来的一天决定
//    所以我们看第四天的，如果第四天比第三天还高，那我们就继续观望（继续更新max）
//    第五天终于跌了，跌多少的时候卖出呢？
//        假设之前的最小值为a，第四天（也就是跌之前的最大值）的价格为b，跌了之后价格为c
//        第二次卖出时价格为d，从a-d可以选择交易1次或者2次
//            只交易一次：利润为p1 = （d-a-fee）
//            交易两次：利润为p2 =（b-a+d-c-2*fee）
//        当交易两次利润比一次利润大时，我们在下跌的时候就应该卖出
//        p2-p1 = b-c-fee>0，也就是b-c>fee所以当跌了的价格超过手续费时我们就应该卖出，这样就能进行多次交易获得更大的利润
//    当遍历到末尾时，只要利润大于0就应该卖出
    public int maxProfit(int[] prices, int fee) {
        int res = 0;
        int min = prices[0];
        int max = prices[0];
        int cur = 0;
        //min记录遍历到的最小值,max记录遍历到的最大值
        //这个最难在于求什么时候卖出,取最小值为购买点,最大值减最小值即为利润
        for(int i = 1; i < prices.length; i++) {
            min = Math.min(min, prices[i]);
            max = Math.max(max, prices[i]);
            cur = Math.max(cur, prices[i] - min - fee);
            //由上述公式推导得,当下跌超过手续费时,就应该卖出
            if(max - prices[i] > fee) {
                res += cur;
                cur = 0;
                min = prices[i];
                max = prices[i];
            }
        }
        res += cur;
        return res;
    }

}
