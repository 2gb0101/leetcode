package Array.Hard;

import java.util.ArrayDeque;
import java.util.Deque;

//Offer: 给定 n 个非负整数，用来表示柱状图中各个柱子的高度
//       每个柱子彼此相邻，且宽度为 1
//Target: 求在该柱状图中，能够勾勒出来的矩形的最大面积
public class _84_largestRectangleArea {
//    解法1：暴力解法
//    可以枚举以每个柱形为高度的最大矩形的面积。
//    具体来说就是：依次遍历柱形的高度，对于每一个高度分别向两边扩散，求出以当前高度为矩形的最大宽度多少。
//    为此，我们需要：
//        左边看一下，看最多能向左延伸多长，找到大于等于当前柱形高度的最左边元素的下标；
//        右边看一下，看最多能向右延伸多长；找到大于等于当前柱形高度的最右边元素的下标。
//        对于每一个位置，我们都这样操作，得到一个矩形面积，求出它们的最大值。
    public int largestRectangleArea1(int[] heights) {
        int len = heights.length;
        // 特判
        if (len == 0) {
            return 0;
        }

        int res = 0;
        for (int i = 0; i < len; i++) {
            // 找左边最后 1 个大于等于 heights[i] 的下标
            int left = i;
            int curHeight = heights[i];
            while (left > 0 && heights[left - 1] >= curHeight) {
                left--;
            }

            // 找右边最后 1 个大于等于 heights[i] 的索引
            int right = i;
            while (right < len - 1 && heights[right + 1] >= curHeight) {
                right++;
            }

            int width = right - left + 1;
            res = Math.max(res, width * curHeight);
        }
        return res;
    }
//    复杂度分析：
//    时间复杂度：O(N^2)，这里 N 是输入数组的长度。
//    空间复杂度：O(1)
//    看到时间复杂度为O(N^2)和空间复杂度为 O(1)的组合
//        那么我们是不是可以一次遍历，不需要中心扩散就能够计算出每一个高度所对应的那个最大面积矩形的面积呢？
//        其实很容易想到的优化的思路就是「以空间换时间」。我们需要在遍历的过程中记录一些信息

//    解法2：以空间换时间，使用栈
//    先搞清楚，要记录什么信息呢？记录高度是不是可以呢？
//      其实是不够的，因为计算矩形还需要计算宽度
//      很容易知道宽度是由下标确定的
//      记录了下标其实对应的高度就可以直接从输入数组中得出
//      因此，应该记录的是下标
//    思路（具体过程可看笔记图解）：
//        只要是遇到了当前柱形的高度比它上一个柱形的高度严格小的时候、
//            一定可以确定它之前的某些柱形的最大宽度
//            并且确定的柱形宽度的顺序是从右边向左边
//        这个现象告诉我们
//            在遍历的时候需要记录的信息就是遍历到的柱形的下标
//            它一左一右的两个柱形的下标的差就是这个面积最大的矩形对应的最大宽度
//    细节
//    在确定一个柱形的面积的时候，除了右边要比当前严格小
//    其实还蕴含了一个条件，那就是左边也要比当前高度严格小
//    那如果是左边的高度和自己相等怎么办呢？
//        之前是只要比当前严格小，才可以确定一些柱形的最大宽度
//        只要是大于或者等于之前看到的那一个柱形的高度的时候，我们其实都不能确定
//        因此确定当前柱形对应的宽度的左边界时，回头看，一定要找到第一个严格小于我们要确定的那个柱形的高度的下标
//        此时中间那些相等的柱形其实就可以当做不存在一样。因为它对应的最大矩形和它对应的最大矩形其实是一样的
//    确定采用的数据结构
//        我们在缓存数据的时候，是从左向右缓存的
//        我们计算出一个结果的顺序是从右向左的，并且计算完成以后我们就不再需要了，符合后进先出的特点
//        因此，我们需要的这个作为缓存的数据结构就是栈
//    本算法的巧妙
//        这个算法经过一次遍历
//        在每一次计算最大宽度的时候，没有去遍历，而是使用了栈里存放的下标信息
//        以 O(1) 的时间复杂度计算最大宽度
//    考虑特殊情况，加入哨兵
//        需要考虑两种特殊的情况：
//            弹栈的时候，栈为空；
//            遍历完成以后，栈中还有元素；
//        为此可以我们可以在输入数组的两端加上两个高度为 0 （或者是 0.5，只要比 1 严格小都行）的柱形
//        这样可以回避上面这两种分类讨论
//
//        这两个站在两边的柱形有一个很形象的名词，叫做哨兵（Sentinel）。
//        有了这两个柱形：
//            左边的柱形（第 1 个柱形）
//                由于它一定比输入数组里任何一个元素小
//                它肯定不会出栈
//                因此栈一定不会为空
//            右边的柱形（第 2 个柱形）
//                因为它一定比输入数组里任何一个元素小
//                它会让所有输入数组里的元素出栈（第 1 个哨兵元素除外）
//
//    这里栈对应到高度，呈单调增加不减的形态，因此称为单调栈（Monotone Stack）
//    它是暴力解法的优化，计算每个柱形的高度对应的最大矩形的顺序由出栈顺序决定
    public int largestRectangleArea(int[] heights) {
        int len = heights.length;
        if (len == 0) {
            return 0;
        }

        if (len == 1) {
            return heights[0];
        }
        int res = 0;
        int[] newHeights = new int[len + 2];
        newHeights[0] = 0;
        System.arraycopy(heights, 0, newHeights, 1, len);
        newHeights[len + 1] = 0;
        len += 2;
        heights = newHeights;

        Deque<Integer> stack = new ArrayDeque<>(len);
        // 先放入哨兵，在循环里就不用做非空判断
        stack.addLast(0);
        for (int i = 1; i < len; i++) {
//          peekLast()：获取元素，但不删除元素。如果集合中没有元素，会返回null。
//          pollLast()：获取元素，但是元素被删除。如果集合中没有元素，会返回null。
            while (heights[i] < heights[stack.peekLast()]) {
                int curHeight = heights[stack.pollLast()];
                int curWidth = i - stack.peekLast() - 1;
                res = Math.max(res, curHeight * curWidth);
            }
            stack.addLast(i);
        }
        return res;
    }
//    复杂度分析：
//    时间复杂度：O(N)，输入数组里的每一个元素入栈一次，出栈一次
//    空间复杂度：O(N)，栈的空间最多为 N
}
