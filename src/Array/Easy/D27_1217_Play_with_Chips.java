package Array.Easy;

//Offer：
//数轴上放置了一些筹码，每个筹码的位置存在数组chips当中。
//你可以对 任何筹码 执行下面两种操作之一（不限操作次数，0 次也可以）：
//将第 i 个筹码向左或者右移动 2 个单位，代价为 0。
//将第 i 个筹码向左或者右移动 1 个单位，代价为 1。
//最开始的时候，同一位置上也可能放着两个或者更多的筹码。
//Target：
//返回将所有筹码移动到同一位置（任意位置）上所需要的最小代价。
public class D27_1217_Play_with_Chips {
//    (找规律) O(n)
//    本题的本质就是统计奇数位置和偶数位置的个数的最小值
//    Min(奇数位置个数，偶数位置个数)

//    解释：
//    根据题意抽象一下
//    第i个筹码移动偶数个位置代价是0
//    移动奇数位置代价是1
//    且最终都可以落到1位置（奇数位置）或者2位置（偶数位置）
//    因为移动2格（即偶数个格子）不需要代价
//    所以原本在偶数位置的元素
//    可以不需要代价移动到2位置
//    而原本是奇数位置的元素可以不费代价的移动到1位置
//    问题就转化为现在所有元素都在1号位置和2号位置了
//		1号位置代表是奇数位置的个数
//		2号位置代表的是偶数位置的个数。
//
//    题目问最小需要多少代价移动到同一个位置
//    那就看看现在是
//    要把1号位置的数全部放到2号位置
//    还是把2号位置的数全部放到1号位置
//    要使得代价最小
//    肯定是看1号和2号哪个位置的元素个数少
//    就把对应少的位置的所有元素移动到多的位置
//    每次移动的代价为1，及最少代价就是
//    Min(1号位置个数，2号位置个数) == Min(奇数位置个数，偶数位置个数)
    public int minCostToMoveChips(int[] chips) {
        int odd = 0, even = 0;
        for (int x : chips) {
            if (x % 2 != 0)
                ++odd;
            else
                ++even;
        }
        return Math.min(odd, even);
    }
}
